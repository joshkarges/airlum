import _ from "lodash";
import { useCallback, useMemo, useReducer, useState, useEffect } from "react";
import {
  ReduxDefaultRootState as DefaultRootState,
  useDispatch,
  useSelector,
} from "react-redux";

// TYPES
export type FetcherInputArg = any; // eslint-disable-line @typescript-eslint/no-explicit-any

/**
 * An async function that takes a **up to 1 argument** and returns a `Promise<T>`.[^1]  If you need to pass in more than 1 argument such as an abort signal, wrap your fetcher in a function that takes an object or array as a single argument and separate the arguments inside that wrapper function.
 *
 * [^1]: Don't pass in a fetcher function constructed on the fly to a hook, name it first.
 * @template T - The promised return type of the function.
 * @example
 * ```ts
 * const fetcher = async ({id, signal}) => {
 *  const response = await fetch(`/api/thing/${id}`, { signal });
 *  return response.json();
 * }
 * @category Extras
 */
export type Fetcher<T, Args extends [] | [any] = [any]> = (
  ...args: Args
) => Promise<T>;

/**
 * An enum that represents a non-errored status of the fetch, and even though it _is_ exported, but you shouldn't need to use it in most cases.
 */
export enum FetchedStatusString {
  /**
   * Before the fetch is sent to the server.
   */
  Idle = "IDLE",
  /**
   * After the fetch is sent to the server, before it succeeds or fails.
   */
  Pending = "PENDING",
  /**
   * After the fetch succeeds and the `data` field is filled with the response.
   */
  Success = "SUCCESS",
}

export type FetchedErrorStatus = {
  message: string;
  code: number;
};

export type FetchedStatus = FetchedStatusString | FetchedErrorStatus;

/**
 * This is the basic building block of the fetchers module, and is the main type that all the other functions and components work with.  It represents the state of a piece of data when fetching it.
 *
 * - You should never have to construct it yourself, it will be created by one of the hooks like `useFetchedResource` or by one of the reducers generated by `makeFetchedResourceReducer` or `makeSingleMultiReducer`.
 * - You should never have to directly access any of the fields except for `data`.  The status field is managed by the actions and reducers, and you can read it with the helper functions `anyIsIdle`, `anyIsPending`, `anyIsSuccess` or `anyIsError`.  The timestamp is only used internally in the reducer to check for stale requests.
 * @template T - The type of data being fetched.
 * @category Extras
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type FetchedResource<T = any> = {
  data: T;
  status: FetchedStatus;
  timestamp: number;
};

/**
 * This covers the case where a fetchedResource might be undefined if it's
 * accessed from an object like MultiSingleState
 */
export type MaybeFetchedResource<T = any> = FetchedResource<T> | undefined;

export const makeIdleFetchedResource = <T>(data: T): FetchedResource<T> => ({
  data,
  status: FetchedStatusString.Idle,
  timestamp: 0,
});

export type AnyAction<K extends string = string, V = any> = {
  type: string;
} & { [key in K]: V };

export type PendingAction<Arg> = {
  type: string;
  opts: Arg;
  timestamp: number;
};

export type SuccessAction<Arg, Data> = {
  type: string;
  opts: Arg;
  data: Data;
  timestamp: number;
};

export type ErrorAction<Arg> = {
  type: string;
  opts: Arg;
  err: any;
  timestamp: number;
};

type FetchingAction<Arg, Data> =
  | PendingAction<Arg>
  | SuccessAction<Arg, Data>
  | ErrorAction<Arg>;

export type FetchingActionResponse<T> = { response?: T; error?: any };

/**
 * An object that ties action `type` string together with the action creator function that creates a "thunk", which is an async function which accepts a reducer's `dispatch` as its only argument.
 * @category Extras
 */
export type FetchingActionDescriptor<
  Args extends [] | [any] = [any],
  Data = any
> = {
  type: string;
  creator: (
    ...args: Args
  ) => (
    dispatch: React.Dispatch<FetchingAction<Args[0], Data>>
  ) => Promise<FetchingActionResponse<Data>>;
};

export type SettingActionDescriptor<V = any> = {
  type: string;
  creator: (arg: V) => AnyAction<"payload", V>;
};

// ACTION TYPE UTILS

const toActionTypeCase = (str: string) => _.snakeCase(str).toUpperCase();
export const toPendingType = (str: string) =>
  toActionTypeCase(`PENDING_${str}`);
export const toSuccessType = (str: string) =>
  toActionTypeCase(`SUCCESS_${str}`);
export const toFailureType = (str: string) =>
  toActionTypeCase(`FAILURE_${str}`);
export const toSettingType = (str: string) => toActionTypeCase(`SET_${str}`);

export const isPendingAction = <Args extends [] | [any]>(
  action: AnyAction,
  descriptor: FetchingActionDescriptor<Args>
): action is PendingAction<Args[0]> =>
  action.type === toPendingType(descriptor.type);
export const isSuccessAction = <Args extends [] | [any], Data>(
  action: AnyAction,
  descriptor: FetchingActionDescriptor<Args, Data>
): action is SuccessAction<Args[0], Data> =>
  action.type === toSuccessType(descriptor.type);
export const isErrorAction = <Args extends [] | [any]>(
  action: AnyAction,
  descriptor: FetchingActionDescriptor<Args>
): action is ErrorAction<Args[0]> =>
  action.type === toFailureType(descriptor.type);
export const isSettingAction = <S extends SettingActionDescriptor>(
  action: AnyAction,
  descriptor: S
): action is ReturnType<S["creator"]> => action.type === descriptor.type;

// ACTIONS

/**
 *  Make a generic action creator that adds the type property to any input object
 * @param {string} type - The action type string
 * */
export const makeActionCreator = <A extends AnyAction = AnyAction>(
  type: string
) => {
  return ({ ...args }: Omit<A, "type">) =>
    ({
      type,
      ...args,
    } as A);
};

/**
 * A trasform function.  It maps a value of type T to type R
 * @template T The input type
 * @template R the output type
 * @param value - the input value
 * @returns type R
 */
export type Parser<T, R = T> = {
  (value: T): R;
};

export type FetchingActionOpts<T, R> = {
  parser?: Parser<T, R>;
};

/**
 * Make a fetching creator from a name, the async fetcher function, and an optional parser.  The "type" will be set to the type-cased version of the name.  The creator function returns an async function which takes dispatch as the only arg.
 * The last argument is an options object with a single option:
 *
 * Name | Type | Defaults | Description |
 * :------ | :------ | :------ | :------ |
 * `parser` | `(response: T) => R` | [_.identity](https://lodash.com/docs/4.17.15#identity) | Optional function to re-parse the response of the fetcher from type T to type R.
 * @template T - The (promised) return type of the fetcher
 * @template R - The return type of the optional parser (defaults to T)
 * @param name - Name of the action.  The 'type' is set to the
 * capitalized SNAKE_CASE version of that name.
 * @param fetcher - The asynchronous fetching function.
 * @param __namedParameters An optional object for customization, see table above for details
 * @returns An action descriptor to be used with reducers and dispatchers.
 * @category Basics
 */
export function makeFetchingActionCreator<
  T,
  R = T,
  Args extends [] | [any] = [any]
>(
  name: string,
  fetcher: Fetcher<T, Args>,
  { parser = _.identity }: FetchingActionOpts<T, R> = {}
): FetchingActionDescriptor<Args, R> {
  const type = toActionTypeCase(name);
  const successCreator = makeActionCreator<SuccessAction<Args[0], R>>(
    toSuccessType(type)
  );
  const pendingCreator = makeActionCreator<PendingAction<Args[0]>>(
    toPendingType(type)
  );
  const failureCreator = makeActionCreator<ErrorAction<Args[0]>>(
    toFailureType(type)
  );
  return {
    type,
    creator: (...args: Args) => {
      return async (dispatch: React.Dispatch<FetchingAction<Args[0], R>>) => {
        const timestamp = Date.now();
        try {
          dispatch(pendingCreator({ opts: args[0], timestamp }));
          const response = await fetcher(...args);
          const data = parser(response);
          dispatch(successCreator({ opts: args[0], data, timestamp }));
          return { response: data };
        } catch (error) {
          console.error(error);
          dispatch(failureCreator({ opts: args[0], err: error, timestamp }));
          return { error };
        }
      };
    },
  };
}

/**
 *  Make a simple synchronous action creator that sets the value of propName as propValue
 * @template V The type of the state being set.
 * @returns An action descriptor to be used with reducers and dispatchers.
 * @category Extras
 */
export function makeSimpleSettingActionCreator<V>(propName: string) {
  const type = toSettingType(propName);
  return {
    type,
    creator: (propValue: V) => ({
      type,
      payload: propValue,
    }),
  } as SettingActionDescriptor<V>;
}

/**
 * Make a fetching action creator for all (name, fetcher) entries in the input object
 * i.e. makes an object from repeatedly calling
 *  makeFetchingActionCreator(key, ...value) from each key-value in the input object
 * NOTE: This only works if all the fetcher functions take exactly 1 argument, and it won't preserve the arg type. :(
 * @param fetcherMap - Object where the keys are action names, and
 *  the values are api fetcher functions, or a 2-element array [fetcher, parser]
 * @returns Object where the keys are the same action names, and the
 *  values are {@link FetchingActionDescriptor}s
 */
export function makeAllFetchingActionCreators(
  fetcherMap: Record<
    string,
    Fetcher<any> | [Fetcher<any>, FetchingActionOpts<any, any>]
  >
) {
  return _.mapValues(fetcherMap, (descriptor, key) => {
    const args = _.isArray(descriptor)
      ? descriptor
      : ([descriptor] as [Fetcher<any>]);
    return args.length > 1
      ? makeFetchingActionCreator(key, args[0], args[1])
      : makeFetchingActionCreator(key, args[0]);
    // Spreading a tuple union is buggy in Typescript: https://github.com/microsoft/TypeScript/issues/43429
  });
}

// REDUCERS
// Same as a ReduxReducer but the input state can't be undefined.  Only for use
// in internal reducers where you're sure the state isn't undefined.
export type Reducer<S, A extends AnyAction = AnyAction> = (
  state: S,
  action: A
) => S;

// To be compatible with redux and other reducer tools, we need to sometimes
// return the "unsure" reducer that can be initialized from an undefined state
export type UnsureReducer<S> = (state: S | undefined, action: AnyAction) => S;

export type UnsureReducerState<Type> = Type extends UnsureReducer<infer State>
  ? State
  : never;

export type StateFromReducerMap<Type> = {
  [StateKey in keyof Type]: UnsureReducerState<Type[StateKey]>;
};

// The 'data' field of a SuccessAction is either a single piece of fetched data
// in the case of makeFetchedResourceReducer, or a map of keys to single pieces
// of data in the case of makeSingleMultiReducer.
export type SuccessData<R> = R extends Record<string, FetchedResource<infer T>>
  ? Record<string, T>
  : R;
export type FetchedReduceMap<T> = {
  pendingReducer?: Reducer<FetchedResource<T>, PendingAction<any>>;
  successReducer?: Reducer<
    FetchedResource<T>,
    SuccessAction<any, SuccessData<T>>
  >;
  failureReducer?: Reducer<FetchedResource<T>, ErrorAction<any>>;
};
export type FetchedResourceReducerOpts<T> = FetchedReduceMap<T> & {
  allowStaleRequests?: boolean;
};

// A request is fresh if it hasn't been requested yet, or if the timestamp on
// the action matches the timestamp of when the resource was requested.
const isRequestFresh = (name = "", state: FetchedResource, action: AnyAction) =>
  action.type === toPendingType(name) || action.timestamp === state.timestamp;

/**
 * Make a reducer function for a fetched resource.  It will take care of updating data as well as the timestamp and status
 *
 * @param name - The action name.  Same as the name given to
 *  makeFetchingActionCreator, or its 'type' property
 * @param initialData - initial value of the 'data' property of the
 *  fetched resource
 * @param options An optional [object](#FetchedResourceReducerOpts) for customization:
 * | Name | Type | Defaults | Description |
 * | ------ | ------ | ------ | ------ |
 * | `pendingReducer` | `Reducer<FetchedResource<T>>` | `(state, action) => ({...state, status: FetchedStatusString.Pending})` | Custom pending reducer if you want the pending action to do something other than just setting `status` to `'PENDING'`
 * | `successReducer` | `Reducer<FetchedResource<T>>` | `(state, action) => ({...state, data: action.data, status: FetchedStatusString.Success})` | Custom success reducer if you want the success action to do something other than just filling the `data` property, and setting `status` to `'SUCCESS'`
 * | `failureReducer` | `Reducer<FetchedResource<T>>` | `(state, action) => ({...state, status: {message: err.message, code: error.response.status}})` | Custom failure reducer if you want the failure action to do something other than just filling the `status` with the err.message and err.response.status.
 * | `allowStaleRequests` | `boolean` | `false` | If your success reducer doesn't just overwrite `data`, maybe you want to accept stale requests. For example, maybe the success reducer concatenates the responses into a big array.
 * @template T
 * @returns The reducer function for a fetched resource
 * @category Basics
 */
export const makeFetchedResourceReducer = <T>(
  name: string,
  initialData: T,
  {
    pendingReducer,
    successReducer,
    failureReducer,
    allowStaleRequests = false,
  }: FetchedResourceReducerOpts<T> = {}
): UnsureReducer<FetchedResource<T>> => {
  const pendingType = toPendingType(name);
  const successType = toSuccessType(name);
  const failureType = toFailureType(name);

  const reducers: FetchedReduceMap<T> = {
    [pendingType]:
      pendingReducer ||
      ((state, action) => ({
        ...state,
        status: FetchedStatusString.Pending,
        timestamp: action.timestamp,
      })),
    [failureType]:
      failureReducer ||
      ((state, action) => ({
        ...state,
        status: {
          message: _.get(action, "err.message", "unknown error"),
          code: _.get(action, "err.response.status", 500),
        },
      })),
    [successType]:
      successReducer ||
      ((state, action) => {
        return {
          ...state,
          data: action.data,
          status: FetchedStatusString.Success,
        };
      }),
  };
  return (
    state = {
      data: initialData,
      status: FetchedStatusString.Idle,
      timestamp: 0,
    },
    action = { type: "" }
  ) => {
    const actionType =
      allowStaleRequests || isRequestFresh(name, state, action)
        ? action.type
        : "";
    // Return the same state if the actionType doesn't match any of the reducers
    // otherwise it was causing infinite loops in a useEffect.
    if (!(actionType in reducers)) return state;
    return {
      ...state,
      ..._.invoke(reducers, actionType, state, action),
    };
  };
};

export type MultiSingleData<T> = Record<string, FetchedResource<T>>;

/**
 * Use this type to specify the type of your state when using [makeSingleMultiReducer](#makeSingleMultiReducer)
 * @category Extras
 */
export type MultiSingleState<T> = FetchedResource<MultiSingleData<T>>;

export type MakeSingleMultiReducerOptionalArgs<T> = {
  multiMerge?: boolean;
  getSingleElementPath?: (action: FetchingAction<any, T>) => string;
  singleReducerOpts?: FetchedResourceReducerOpts<T>;
  multiReducerOpts?: Omit<
    FetchedResourceReducerOpts<MultiSingleData<T>>,
    "successReducer"
  > & {
    successReducer: Reducer<
      MultiSingleState<T>,
      SuccessAction<[any], Record<string, T>>
    >;
  };
};

// Update the data so that all the elements are FetchedResources
const makeMultiSuccessReducer =
  <Data>(
    merge: boolean
  ): NonNullable<
    MakeSingleMultiReducerOptionalArgs<Data>["multiReducerOpts"]
  >["successReducer"] =>
  (state, action) => ({
    ...state,
    status: FetchedStatusString.Success,
    data: {
      ...(merge ? state.data : {}),
      ..._.mapValues(
        action.data,
        (singleData) =>
          ({
            status: FetchedStatusString.Success,
            timestamp: state.timestamp,
            data: singleData,
          } as FetchedResource)
      ),
    },
  });

/**
 * Make a reducer function for a fetched resource that can be fetched singularly or plurally.  It will take care of updating data as well as the timestamp and status for both the single fetch and the multi fetch.
 * @param singleName - The action name of the single fetch.  Same as
 *  the name given to makeFetchingActionCreator, or its 'type' property
 * @param multiName - The action name of the multi fetch.
 * @param initialSingleData - The initial data of a single fetched resource.
 * @param __namedParameters An optional object for customization:
 * Name | Type | Default | Description
 * :---- | :---- | :---- | :----
 * `getSingleElementPath` | `(action: AnyAction) => string` | `(a) => a.opts` | Function to get the path to the single element of the multi data state with the action (a) as input
 * `multiMerge` | `boolean` | `false` | Whether to merge the result of a  multi fetch with the old data, or replace it. Has no affect when `multiReducerOpts.successReducer` is set.
 * `singleReducerOpts` | [FetchedResourceReducerOpts<T>](#FetchedResourceReducerOpts) | {} | Optional object to customize the single reducer.
 * `multiReducerOpts` | [FetchedResourceReducerOpts<T>](#FetchedResourceReducerOpts) | {} | Optional object to customize the multi reducer.
 *
 * @template T - The type of a single fetched resource's data prop.
 * @returns The reducer function for a single/multi-fetched resource
 * @example
 * Resulting state will look like:
 * ```tsx
 * FetchedResource<{
 *  [key: string]: FetchedResource<T>
 * }>
 * ```
 */
export const makeSingleMultiReducer = <T>(
  singleName: string,
  multiName: string | null,
  initialSingleData: T,
  {
    multiMerge = false,
    getSingleElementPath = _.property("opts"),
    singleReducerOpts,
    multiReducerOpts,
  }: MakeSingleMultiReducerOptionalArgs<T> = {}
): UnsureReducer<MultiSingleState<T>> => {
  const singleReducer = makeFetchedResourceReducer<T>(
    singleName,
    initialSingleData,
    singleReducerOpts
  );
  const combinedMultiReducerOpts = {
    successReducer: makeMultiSuccessReducer<T>(multiMerge),
    ...(multiReducerOpts || {}),
  };
  const multiReducer = makeFetchedResourceReducer<MultiSingleData<T>>(
    multiName === null ? "no_multi_actions" : multiName,
    {},
    combinedMultiReducerOpts
  );
  return (state, action) => {
    const newState = multiReducer(state, action);
    if (action.type.endsWith(singleName)) {
      const singleElementPath = getSingleElementPath(
        action as FetchingAction<any, T>
      );
      const singleElementState = _.get(newState.data, singleElementPath);
      const newSingleElementState = singleReducer(singleElementState, action);
      if (singleElementState !== newSingleElementState) {
        return {
          ...newState,
          data: {
            ...newState.data,
            [singleElementPath]: newSingleElementState,
          },
        };
      }
    }
    return newState;
  };
};

// STATUS

type statusIsFunctionType = (status: FetchedStatus) => boolean;
const statusIsIdle: statusIsFunctionType = (status) =>
  status === FetchedStatusString.Idle;
const statusIsPending: statusIsFunctionType = (status) =>
  status === FetchedStatusString.Pending;
const statusIsSuccess: statusIsFunctionType = (status) =>
  status === FetchedStatusString.Success;
const statusIsError: statusIsFunctionType = _.isObject;

const anyFetchedResourceIs =
  (fn: statusIsFunctionType, resultIfUndefined = false) =>
  (...listOfFetchedResources: MaybeFetchedResource[]) =>
    _.some(listOfFetchedResources, (resource) =>
      _.has(resource, "status") ? fn(resource!.status) : resultIfUndefined
    );

/**
 * Util predicate function for the status of a fetched resource
 * @param listOfFetchedResources Any number of fetched resources
 * @returns {boolean} whether any of the fetched resources are Idle, Pending, Success, or Error
 *
 * @example
 * const [myResource1, fetchResource1] = useFetchedResource(apiCall);
 * const [myResource2, fetchResource2] = useFetchedResource(apiCall);
 * const isPending = anyIsPending(myResource1, myResource2));
 */
export const anyIsError = anyFetchedResourceIs(statusIsError);

/** See [`anyIsError`](#anyIsError) (returns true if resource is undefined) */
export const anyIsIdle = anyFetchedResourceIs(statusIsIdle, true);

/** See [`anyIsError`](#anyIsError) */
export const anyIsPending = anyFetchedResourceIs(statusIsPending);

/** See [`anyIsError`](#anyIsError) */
export const anyIsSuccess = anyFetchedResourceIs(statusIsSuccess);

/**
 * Get the error message from a fetched resource if the error message exists.
 * @param response A fetched resource to get the error message from
 * @returns The error message or `null`
 */
export const errorMessage = (response: MaybeFetchedResource) => {
  if (!anyIsError(response)) return null;
  return _.get(response, "status.message", null) as string | null;
};

// HOOKS

export type UseFetchedResourceOpts<T, R> = FetchingActionOpts<T, R> &
  FetchedResourceReducerOpts<R> & { initialData: R };

/**
 * If there's one thing you get out of this module, it should be this hook.  It works like a `useState` call, except instead of an initial value, you give an async function.
 *
 * @param fetcher The async [`Fetcher`](#fetcher) function.  Needs to be a stable reference.
 * @param initialFetchOpts Object of options to customize.[^1]  Basically every option you can pass to [makeFetchingActionCreator](#makeFetchingActionCreator) and [makeFetchedResourceReducer](#makeFetchedResourceReducer) plus `initialData`.
 * [^1]: It's important to note that the `options` you pass in gets memoized internally, and any changes to it get's ignored.  For example, you see in the kitchen sink example that the `initialData` creates a new array literal `[]` every time, which technically changes its reference, but all subsequent `options` are essentially ignored so it doesn't effect any hook dependencies internally.
 * Name | Type | Defaults | Description |
 * :------ | :------ | :------ | :------ |
 * `initialData?` | `T` | undefined | This is what [`data`](#fetchedresource) will be until the fetch succeeds.
 * `parser?` | ... | ... | See [makeFetchingActionCreator](#makeFetchingActionCreator)
 * `successReducer?` | ... | ... | See [makeFetchedResourceReducer](#makeFetchedResourceReducer) |
 * `failureReducer?` | ... | ... | See [makeFetchedResourceReducer](#makeFetchedResourceReducer) |
 * `allowStaleRequests?` | ... | ... | See [makeFetchedResourceReducer](#makeFetchedResourceReducer) |
 *
 * This hook has three generic template params (which you shouldn't need to specify for most cases): `T` and `R`.  They'll be inferred by the fetcher and options you pass in.
 * @template T The Promised return type of the fetcher.
 * @template R The return type of the optional `parser`.
 * @template Args The type of the arguments that can be passed into the fetcher.
 * @example
 * Let's pretend we have an apiCall like
 *
 * `const apiCall = () => Promise((resolve) => setTimeout(() => resolve('123'), 500));`
 *
 * Basic Usage:
 * ```typescript
 * const [resource, fetchMyData] = useFetchedResource(apiCall);
 * // resource.data is undefined until fetchMyData() is called and the apiCall responds successfully.
 * // Then `data` is set to that response ('123' in this example).
 * // If multiple requests are made all at once, we'll only take the response from the most recent request.
 * ```
 *
 * Kitchen Sink Usage:
 * ```typescript
 * const [resource, fetchMyData] = useFetchedResource(apiCall, {
 *   initialData: [] as number[],
 *   parser: (str: string) => Number(str),
 *   successReducer: (state: FetchedResource<number>, {opts, data, timestamp}: any) => ({
 *     ...state,
 *     data: [...state.data, data],
 *     status: FetchedStatusString.Success
 *   }),
 *   failureReducer: (state: FetchedResource<number>, {opts, err, timestamp}: any) => ({
 *      ...state,
 *      status: {
 *        message: err.response.data,
 *        code: err.response.status,
 *      },
 *   }),
 *   allowStaleRequests: true,
 * });
 * // resource.data is [] until fetchMyData() is called and the apiCall responds successfully.
 * // Then that response is parsed into a number and pushed onto the end of the `data` array.
 * // If multiple requests are made all at once, each response will be accepted and pushed on to the `data` array in the order in which the responses return.
 * ```
 * @category Basics
 */
export const useFetchedResource = <T, R = T, Args extends [] | [any] = [any]>(
  fetcher: Fetcher<T, Args>,
  initialFetchOpts = {} as UseFetchedResourceOpts<T, R>
): [FetchedResource<R>, Fetcher<FetchingActionResponse<R>, Args>] => {
  const [fetchOpts] = useState(initialFetchOpts);
  const {
    initialData,
    successReducer,
    failureReducer,
    parser,
    allowStaleRequests,
  } = fetchOpts;
  const { action, reducer, initialState } = useMemo(() => {
    const name = _.uniqueId(fetcher.name);
    const action = makeFetchingActionCreator(name, fetcher, { parser });
    const reducer = makeFetchedResourceReducer(name, initialData, {
      successReducer,
      failureReducer,
      allowStaleRequests,
    });
    const initialState = reducer(
      { data: initialData, timestamp: 0, status: FetchedStatusString.Idle },
      { type: "" }
    ); // Hack 2 arguments in to get the initial fetched resource state
    return { action, reducer, initialState };
  }, [
    fetcher,
    initialData,
    parser,
    successReducer,
    failureReducer,
    allowStaleRequests,
  ]);

  const [state, dispatch] = useReducer(reducer, initialState);
  const fetch = useCallback(
    (...args: Args) => action.creator(...args)(dispatch),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [dispatch, action]
  );
  return [state, fetch]; // readonly tuple
};

/**
 * Helper function to fetch a resource if it hasn't been fetched yet using the useEffect hook.
 * (Warning: Be careful that this is not called multiple times on the same resource within the same render cycle.  Otherwise the useEffect callback will be queued multiple times and be fetched multiple times)
 * @param resource - The resource that needs fetching
 * @param fetcher - The async fetcher function
 * @param fetcherArg - The input to the fetcher action function.
 */
export const useEffectIfNotFetchedYet = <
  T,
  R = T,
  Args extends [] | [any] = [any]
>(
  resource: FetchedResource<R> | undefined,
  fetcher: (...args: Args) => any,
  ...fetcherArgs: Args
) => {
  useEffect(() => {
    const notFetchedYet = !resource || anyIsIdle(resource);
    const nonFalseyArgs = fetcherArgs.length === 0 || _.some(fetcherArgs);
    if (nonFalseyArgs && notFetchedYet) fetcher(...fetcherArgs);
  }, [fetcherArgs, resource, fetcher]);
};

/**
 * Combines `useFetchedResource` and `useEffectIfNotFetchedYet`
 * @param fetcher (...opts) => Promise
 * @param initialFetchOpts : UseFetchedResourceOpts
 * @returns [FetchedResource, Fetcher]
 */
export const useFetch = <T, R = T, Args extends [] | [any] = [any]>(
  fetcher: Fetcher<T, Args>,
  initialFetchOpts = {} as UseFetchedResourceOpts<T, R>,
  ...fetcherArgs: Args
) => {
  const resourceAndFetcher = useFetchedResource(fetcher, initialFetchOpts);
  const [resource, fetch] = resourceAndFetcher;
  useEffectIfNotFetchedYet<void, R, Args>(resource, fetch, ...fetcherArgs);
  return resourceAndFetcher;
};

// REDUX DISPATCHERS

// Convenience hook which returns the functions that dispatch the input actions to the redux store
export const useDispatcher = <Args extends [] | [any] = [any], Data = any>(
  action: FetchingActionDescriptor<Args, Data>
) => {
  const dispatch = useDispatch();
  return useCallback(
    (...args: Args) => action.creator(...args)(dispatch),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [action, dispatch]
  );
};

// REDUX COMBINED SELECTOR & DISPATCHER

/**
 * Like useState, but for redux
 * @param {string} statePath - The _.get style path of the redux store to get
 *  the element at.
 * @param {FetchingActionDescriptor} actionDescriptor - The action that ultimately sets
 *  that value at that statePath.
 * @returns {[*, (arg: Params<typeof actionDescriptor.creator>) => AnyAction | ThunkAction]}
 *  [stateValue, dispatcher] - Like state and setState return of useState, but
 *  for Redux
 */
export function useReduxState<
  K extends keyof DefaultRootState,
  Args extends [] | [any],
  Data
>(
  statePath: K,
  actionDescriptor: FetchingActionDescriptor<Args, Data>
): [DefaultRootState[K], Fetcher<FetchingActionResponse<Data>, Args>];
export function useReduxState<Args extends [] | [any], Data>(
  statePath: string,
  actionDescriptor: FetchingActionDescriptor<Args, Data>
): [any, Fetcher<FetchingActionResponse<Data>, Args>] {
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const selector = useCallback(_.property<DefaultRootState, any>(statePath), [
    statePath,
  ]);
  const stateValue = useSelector(selector);
  const dispatcher = useDispatcher(actionDescriptor);
  return [stateValue, dispatcher];
}

// REDUX SELECTORS

type OneInOneOut<I, O> = (input: I) => O;

/**
 * Select a portion of the state using the prefix argument as the path in the state.
 * This is just a slight convenience to using the useSelector hook which take the entire state in the callback
 * @template T The key type.  A string that is either a key of the DefaultRootState, or a _.get style path.
 * @template S The portion of the State accessed by the prefix: T.
 * @template R The return type of the selector (defaults to S)
 * @param prefix - The path to the portion of the state you want to use for the returned hook
 * @param [selector] - An optional function that takes the portion of the state as input
 * @returns The return of the selector or the portion of the state itself
 * @example foo = useSelectorWithPrefix('foo')
 * @example fooStr = useSelectorWithPrefix('foo', (foo) => foo.toString())
 */
export function useSelectorWithPrefix<T extends keyof DefaultRootState>(
  prefix: T
): DefaultRootState[T];
export function useSelectorWithPrefix<
  T extends keyof DefaultRootState,
  R = DefaultRootState[T]
>(prefix: T, selector: OneInOneOut<DefaultRootState[T], R>): R;
export function useSelectorWithPrefix<S = any>(prefix: string): S;
export function useSelectorWithPrefix<S, R = any>(
  prefix: string,
  selector: OneInOneOut<S, R>
): R;
export function useSelectorWithPrefix<T extends keyof DefaultRootState, S, R>(
  prefix: T | string,
  selector: OneInOneOut<S, R> = _.identity
) {
  return useSelector((state) => {
    return selector(_.get(state, prefix) as S);
  }, _.isEqual);
}

export interface SelectorHookWithBakedPath<S, R = S> {
  (): R;
  <R2>(selector: OneInOneOut<S, R2>): R2;
}

/**
 * Make a quick selector hook of a portion of the state
 * @template T The key type.  A string that is either a key of the DefaultRootState, or a _.get style path.
 * @template S The portion of the State accessed by the prefix: T.
 * @template R The return type of the selector (defaults to S)
 * @param prefix - The path to the portion of the state you want to use for the returned hook
 * @param [selector] - An optional function that takes the portion of the state as input
 * @returns A hook that gets the return of the selector or the portion of the state itself
 * @example
 * const useFooSelector = makeSelectorWithPrefix('foo');
 * // Use the generated hook in a component like below
 * const foo = useFooSelector();
 * const fooStr = useFooSelector((foo) => foo.toString());
 * @example
 * const useFooSelector2 = makeSelectorWithPrefix('foo', (foo) => foo.toString());
 * // Use the generated hook in a component like below
 * const fooStr = useFooSelector2();
 * const fooArr = useFooSelector2((foo) => [foo]);
 * @example
 * // You can use _.get path syntax, but you'll have to explicitly provide the type of the state portion in a generic parameter
 * const useNestedSelector = makeSelectorWithPrefix<State['foo']['bar']>('foo.bar');
 */
export function makeSelectorWithPrefix<T extends keyof DefaultRootState>(
  prefix: T
): SelectorHookWithBakedPath<DefaultRootState[T]>;
export function makeSelectorWithPrefix<T extends keyof DefaultRootState, R>(
  prefix: T,
  defaultSelector: OneInOneOut<DefaultRootState[T], R>
): SelectorHookWithBakedPath<DefaultRootState[T], R>;
export function makeSelectorWithPrefix<S>(
  prefix: string
): SelectorHookWithBakedPath<S>;
export function makeSelectorWithPrefix<S, R>(
  prefix: string,
  defaultSelector: OneInOneOut<S, R>
): SelectorHookWithBakedPath<S, R>;
export function makeSelectorWithPrefix<T extends keyof DefaultRootState, S, R>(
  prefix: T | string,
  defaultSelector?: OneInOneOut<S, R>
) {
  return <R2>(selector?: OneInOneOut<S, R2>) => {
    return selector
      ? useSelectorWithPrefix(prefix, selector)
      : defaultSelector
      ? useSelectorWithPrefix(prefix, defaultSelector)
      : useSelectorWithPrefix(prefix);
  };
}
